---
layout: post
title: "Oracle的学习1"
date: 2019-10-11 13:26:40

tags:
- 数据库
- Oracle
---
* content
{:toc}

Oracle增删改查基础命令的学习












## 一、Oracle 11g的介绍及安装  
### 1. Oracle数据库  
- 系统可移植性好、使用方便、功能强大  
- 是一种高效率、可靠性好的，适应高吞吐量的数据库解决方案  

### 2. Oracle产品介绍  
- 1979年，甲骨文公司推出Oracle1，世界上第一个基于sql标准的关系数据库产品  
- Oracle 9i：i表示Internet  
- Oracle 11g：g代表网格计算（分布式），提升了分布式数据库的使用，目前的主流  
- Oracle 12c：c代表云计算，支持云服务，是现在的最新版本  

### 3. Oracle 11g下载  
- www.oracle.com
- 登录下载Oracle 11g企业版  

### 4. 安装前建议  
- 关闭防火墙  
- 断网（不是必须的）  

### 5. 安装过程  
- 字符集采用utf-8  
- 管理口令设为：Mm123456  
- 用户：sys/system/scott  

### 6. Oracle服务  
- 全改为手动禁用   
- OracleOraDb11g_home1TNsListener：监听服务打开  
- OracleServiceORCL：实例服务打开  

### 7. Oracle卸载  
- 使用Oracle提供的卸载程序卸载  
- 重启电脑，进入安全模式（按住F8）
- 在安全模式下，找到系统上对应的磁盘路径删除Oracle文件  
- 运行注册表（regedit）搜索（Ctrl+F）所有与Oracle相关的内容并删除  
- 重启电脑后就可以重新执行安装  

### 8. 数据库界面创建工具：DBCA  
- DBCA是Oracle11g提供的一个具有图形化用户界面的工具，用来帮助数据库管理员快速、直观地创建数据库  
- DBCA可以通过“开始”菜单中的Oracle程序组选项来启动  

### 9. 数据库管理工具：SQL Developer  
- 新建连接，连接名为myorcl,用户名为scott，口令Mm123456,SID(数据库标识)为xscj  

### 10. 命令管理工具：SQL Plus  
- 直接在开始菜单打开SQL Plus，输入用户名密码连接  
- 在命令行输入sqlplus，再输入用户名密码连接  

### 11. 以界面方式创建数据库（采用DBCA） 

## 二、数据库操作(增删改)  
### 1. 表操作  

```
- 表结构：每个表都包含一组固定的列，而列由数据类型（datatype）和长度（length）两部分，以描述该表所代表的实体的属性  
- 记录：每个表包含了若干行数据，它们是表的“值”，其中的一行称为一个记录，因此，表是记录的有限集合  
- 字段：每个记录由若干个数据项构成，将构成记录的数据项称为字段  
- 关键字：若表中记录的某个字段或字段组合能唯一标识记录，则称该字段（字段组合）为候选关键字。若一个表有多个候选关键字，则选定其中一个为主关键字（primary key），也称主键  
```

### 2. 创建表

```
  在以自己的模式创建表时，必须拥有createtable系统权限，在其他用户模式下创建表时，必须拥有createanytable系统权限  
- 语法格式  
  CREATE TABLE [<用户方案名>.]<表名>  
  (  
  <列名1> <数据类型> [DEFAULT <默认值>] [<列约束>]  
  <列名2> <数据类型> [DEFAULT <默认值>] [<列约束>]  
  [,...n]  
  <表约束> [,...]  
  )  
  [AS <子查询>]  

- 说明  
  用户方案名：用户方案是指该表所属的用户，如果省略则默认为当前登录的用户  
  default：关键字DEFAULT指定某一列的默认值。默认值的数据类型必须与该列的数据类型相匹配，列的长度必须足以容纳这一表达式值。  
  列约束：定义完整性约束作为列定义的一部分，该子句的语法为： 
    [NOT] NULL  
    [UNIQUE]  
    [PRIMARY KEY]  
    [REFERENCES [<用户方案名>.] <表名>(<列名>)]  
    [CHECK(<条件表达式>)]  

  表约束：定义一个完整性约束作为表定义的一部分  
  AS <子查询>：表示将由子查询返回的行插入到所创建的表中  

- 查看表结构：desc <表名>  

- 如果表的主键由两个或多个列组成，则必须使用`PRIMARY KEY`关键字定义为表的完整性约束  
  CREATE TABLE <表名>  
  (  
  <列名1> <数据类型> [DEFAULT <默认值>] [<列约束>] [,...n]  
  PRIMARY KEY(<列名1>,<列名2>[,...n])  
  )  

- 创建备份表  
  CREATE TABLE <新表名>  
  AS SELECT * FROM <原表名>  

- 复制表结构  
  CREATE TABLE <新表名>  
  AS SELECT * FROM XS WHERE 1=2;
```

### 3. 修改表  

```
- 语法格式
  ALTER TABLE [<用户方案名>.]<表名>  
  [ADD(<新列名> <数据类型> [DEFAULT <默认值>] [列约束] [,...n])] /*增加新列*/  
  [MODIFY([<列名> [<数据类型>] [DEFAULT <默认值>] [列约束] [,...n])] /*修改已有列属性*/  
  [<DROP>子句] /*删除列或约束条件*/  

- 说明  
  ADD子句:用于向表中增加一个新列,新的列定义和创建表时定义列的的格式一样,一次可添加多个列,中间用逗号隔开  
  MODIFY子句:用于修改表中某列的属性(数据类型/默认值等),在修改数据类型时需要注意,如果表中该列所存数据的类型与将要修改的列类型冲突,则会发生错误  
  DROP子句:该子句用于从表中删除指定的字段或约束,语法格式为:  
    DROP[  
    COLUMN <列名>  
    |PRIMAYY [KEY]  
    |UNIQUE(<列名>,...n)  
    |CONSTRAINT <约束名>  
    |[CASCADE]  
    ]  
```

### 4. 删除表  

```
- 语法格式:  
  DROP TABLE [<用户方案名>.]<表名>  
```

### 5. 插入记录  

```
- INSERT语句  
  语法格式:  
    INSERT INTO <表名>[(<列名1>,<列名2>,...n)]  
    VALUES(<列值1>,<列值2>,...n)  
  利用`INSERT语句`还可以把一个表中的部分数据插入到另一个表中,但结果集中每行数据的字段数、字段的额数据类型要与被操作的表完全一致,语法格式为:  
    INSERT INTO <表名>  
    <结果集>  

- MERGE语句  
  在Oracle 12c中有MERGE语句,用于根据与源表连接的结果,对 目标表执行插入、更新或删除操作。例如,根据在一个表中找到的差异在另一个表中插入、更新或删除行,这种方法可以对两个表进行信息同步。语法格式如下:  
    MERGE INTO <目标表名>  
    USING <源表名> ON (<条件表达式>)  
    WHEN MATCHED THEN {UPDATE SET...|DELETE...}  
    WHEN NOT MATCHED THEN INSERT(...) VALUES(...)  
```

### 6. 删除记录  

```
- DELETE语句  
  语法格式:  
    DELETE FROM <表名>  
    [WHERE <条件表达式>]  
  该语句的功能为从指定的表中删除满足条件的行.若省略WHERE子句,表示删除所有的行  

- TRUNCATE TABLE语句  
  如果确实要删除一个大表里的全部记录,可以用TRUNCATE TABLE语句,它可以释放占用的数据块表空间,此操作不可回退,谨慎使用。语法格式为:  
    TRUNCATE TABLE <表名>  
```

### 7. 修改记录  

```
- 语法格式:
  UPDATE <表名>  
  SET <列名>={<新值>|<表达式>}[,...n]  
  [WHERE <条件表达式>]  
- 该语句在指定表的满足条件的记录中,由SET指定的各列的列值设置为SET指定的新值。若不使用WHERE子句,则更新所有记录的 指定列值  
```

## 三、数据库查询  
### 1. 语法格式  

```
  SELECT <列> FROM  <表或视图>  
  [WHERE <条件表达式>]  
  [GROUP BY <分组表达式>]  
  [HAVING <分组条件表达式>]  
  [ORDERR BY <排序表达式> [ASC|DESC]]  
```

### 2. 选择列  

```
- 选择表中的列组成结果表,语法格式为:
  SELETE [ALL|DISTINCT] <列名列表>
  其中<列名列表>指出了结果的形式,其主要格式为:
    { * /*选择当前表或视图的所有列*/  
     |{<表名>|<视图>}.* /*选择指定的表或视图的所有列*/  
     |{<列名>|<表达式>} [[AS] <列别名>] /*选择指定的列*/  
     |<列标题>=<列名表达式> /*选择指定列并更改列标题*/  
    }[,...n]  

- 选择一个表中指定的列  
  使用SELECT语句选择一个表中的某些列,各列名之间要以逗号分隔,语法格式为:  

    SELECT <列名1>[,<列名2>[,...n]]  
    FROM <表名>  
    [WHERE <条件表达式>]  

- 修改查询结果中的列标题  
  如希望查询结果中的某些列或所有列显示时使用自己选择的列标题,可以在列名之后使用AS子句指定一个列别名来替代查询结果的列标题  

- 计算列值  
  使用SELECT对列进行查询时,在结果中可以输出对列值计算后的值,即SELECT语句可以使用表达式作为结果,格式为:  
    SELECT <表达式>[,<表达式>]  

- 消除结果集中的重复行  
  对表只选择其某些列时,可能会出现重复行。可以使用DISTINCT关键字消除结果集中的重复行,其格式是:
    SELECT DISTINCT <列名>[,<列名>...]
  关键字DISTINCT的含义是对结果集中的重复行只选择一个,保证行的唯一性。
```

### 3. 选择行

```
- 表达式的比较  
  比较运算符用于比较两个表达式值,共有个,分别是:=,<,<=,>,>=,<>,!=  
  比较运算的格式为:  
    <表达式1>{=|<|<=|>|>=|<>|!=}<表达式2>  
  当两个表达式值均不为空值(NULL)时,比较运算返回逻辑值TRUE(真)或FALSE(假);而当两个表达式值中有一个为空值或都为空值时,比较运算将返回UNKNOWN  

- 模式匹配  
  LIKE谓词用于指出一个字符串是否与指定的字符串相匹配,其运算对象可以是char,varchar2和date类型的数据,返回逻辑值TRUE或FALSE。LIKE谓词表达式的格式为:  
    <字符串表达式1>[ NOT ]LIKE<字符串表达式2>[ ESCAPE'<转义字符>']  
  在使用LIKE时,可以使用两个通配符:"%"和"_"。若使用带"%"通配符的LIKE进行字符串比较,模式字符串中的所有字符都有意义,包括起始或尾随空格。  

- 范围比较  
  用于范围比较的关键字有两个:BETWEEN和IN  
  当要查询的条件是某个值的范围时,可使用BETWEEN关键字,BETWEEN关键字指出查询范围,格式为:
    <表达式>[ NOT ] BETWEEN <表达式1> AND <表达式2>  
  当不使用NOT时,若表达式的值在表达式1与表达式2之间(包括这个值),则返回TRUE,否则返回FALSE;使用NOT时,返回值刚好相反  

- 空值比较  
  当需要判定一个表达式的值是否为空值时,使用IS NULL关键字,格式为:
    <表达式> IS [NOT] NULL  
  当不使用NOT时,若表达式的值为空值,返回TRUE,否则返回FALSE;当使用NOT时,结果刚好相反  

- 子查询  
  子查询通常与谓词IN、EXIST及比较运算符结合使用  
  (1) IN子查询  
    IN子查询用于进行一个给定值是否在子查询结果集中的判断,格式为:  
      <表达式>[ NOT ] IN (<子查询>)  
    当表达式与子查询的结果表中的某个值相等时,IN谓词返回TRUE,否则返回FALSE;若使用NOT,则返回的值刚好相反  
    在执行包含子查询的SELECT语句时,系统先执行子查询,产生一个结果表,再执行查询  
  (2) 比较子查询  
    这种子查询可以认为是IN子查询的扩展,它使表达式的值与子查询的结果进行比较运算,格式为:  
      <表达式>{=|<|<=|>|>=|<>|!=}{ALL|SOME|ANY}(<子查询>)  
    其中,ALL、SOME和ANY关键字说明对比较运算的限制。ALL指定表达式要与子查询结果集中的每个值都进行比较,当表达式与每个值都满足比较的关系时,才返回TRUE;SOME和ANY表达式只要与子查询结果集中的某个值满足比较的关系时,就返回TRUE  
  (3) EXISTS子查询  
    EXISTS谓词用于测试子查询的 结果是否为空表,若子查询的结果集不为空,则EXISTS返回TRUE,否则返回FALSE。EXISTS还可以与NOT结合使用,即NOT EXISTS,其返回值与EXISTS刚好相反,格式为:  
      [NOT]EXISTS(<子查询>)  
```

### 4. 连接查询  
```
- 连接谓词  
  可以在SELECT语句的WHERE子句中使用比较运算符给出连接条件对表进行连接,将这种表示形式称为连接谓词  

- 以JOIN关键字指定的连接  
  Oracle的PL/SQL语言扩展了以JOIN关键字连接的表示方式,增强了表的连接运算能力。连接表的格式为:  
    <表名> <连接类型> <表名> ON <条件表达式>  
    |<表名> CROSS JOIN <表名>  
    |<连接表>  
    其中,<连接类型>的格式为:  
    <连接类型>::=  
    [INNER|{LEFT|RIGHT|FULL}[OUTER]] CROSS JOIN  
  其中,INNER表示内连接,OUTER表示外连接,CROSS JOIN表示交叉连接,因此,以JOIN关键字指定的连接有三种类型  

- 内连接   
  内连接按照ON所指定的连接条件合并两个表,返回满足条件的行(不去重)  

- 外连接  
  外连接的结果表不但包含满足连接条件的行,还包括响应表中的所有行。包括以下三种:  
  (1) 左外连接(LEFT OUTER JOIN):结果表中处理包括满足条件的行外,还包括左表的所有行  
  (2) 右外连接(RIGHT OUTER JOIN):结果表中处理包括满足条件的行外,还包括右表的所有行  
  (3) 完全外连接(FULL OUTER JOIN):结果表中处理包括满足条件的行外,还包括两个表的所有行  

- 交叉连接  
  交叉连接实际上是将两个表进行笛卡尔积运算,结果表是由第一个表的每一行和第二个表的每一行拼接后形成的表,因此其行数等于两表行数之积  
```

### 5. 汇总
```
- 统计函数   
  (1) SUM和AVG函数  
  SUM/AVG([ALL|DISTINCT] <表达式>)  
  其中表达式还可以是常量、列、函数。SUM和AVG函数只能对数值型数据进行计算  
  ALL表示对所有值进行运算,DISTINCT表示去除重复值,默认为ALL  
  SUM/AVG函数计算时忽略NULL值  
  (2) MAX和MIN函数  
  MAX/MIN([ALL|DISTINCT] <表达式>)  
  其中表达式的数据类型可以是数值、字符和时间日期类型。
  ALL表示对所有值进行运算,DISTINCT表示去除重复值,默认为ALL  
  MAX/MIN函数计算时忽略NULL值  
  (3) COUNT函数  
  COUNT({[ALL|DISTINCT] <表达式>}|*)
  ALL表示对所有值进行运算,DISTINCT表示去除重复值,默认为ALL,选择*时将统计总行数  
  COUNT函数计算时忽略NULL值  

- GROUP BY子句  
  GROUP BY子句用于对表或视图中的数据按字段分组,语法格式为:  
  GROUP BY [ALL] <分组表达式>[,...n]  
  分组表达式通常包含字段名,指定ALL将显示所有组  
  使用GROUP BY子句后,SELECT子句中的列表中只能包含在GROUP BY中指出的列或在统计函数中指定的列

- HAVING子句  
  [HAVING <条件表达式>]  
  HAVING子句的查询条件与WHERE子句类似,不同的是HAVING子句可以使用统计函数,而WHERE子句不可以  
```

### 6. 排序
```
[ORDER BY {<排序表达式> [ASC|DESC]}[,...n]]  
其中排序表达式可以是列名、表达式或一个正整数,当表达式是一个正整数时,表示按表中的该位置上列排序  
关键字是ASC表示升序排列,DESC表示降序排列,系统默认值是ASC
```

### 7. 合并
```
使用UNION子句可以将两个或多个SELECT查询的结果合并成一个结果集,其语法格式为:
<SELECT 查询语句1>  
UNION [ALL] <SELECT查询语句2>  
[UNION [ALL] <SELECT查询语句2> [...n]]  
使用UNION组合两个查询的结果集的两条基本规则如下:
①所有查询中的列数和列的顺序必须相同  
②数据类型必须兼容  
```


## 四、视图
### 1. 视图的优点  
```
- 为用户集中数据,简化用户的数据查询和处理  
- 屏蔽数据库的复杂性  
- 简化用户权限的管理(增加了安全性)  
- 便于数据共享  
- 可以重新组织数据,以便输出到其他应用程序中  
```

### 2. 创建视图
```  
CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW [<用户方案名>.]<视图名>  
  [(<列名>[,...n])]  
AS   
<SELECT查询语句>  
[WITH CHECK OPTION[CONSTRAINT <约束名>]]  
[WITH READ ONLY]  

创建视图时,源表可以是基表也可以是视图  

例:创建CS_KC视图,包括计算机专业各学生的学号、其选修的课程号及成绩,要保证对该视图的修改都符合专业名为"计算机"这个条件  
CREATE OR REPLACE VIEW CS_KC  
  AS  
  SELECT XSB.学号,课程号,成绩  
    FROM XSB,CJB  
    WHERE XSB.学号=CJB.学号 AND 专业='计算机'  
    WITH CHECK OPTION;
```

### 3. 查询视图
```
跟查询表一样  
例:查找计算机专业的学生学号和选修的课程号  
SELECT 学号,课程号  
  FROM CS_KC;
```

### 4. 修改视图的定义
```
例:修改视图CS_KC的定义,增加姓名、课程名和成绩字段  
CREATE OR REPLACE FORCE VIEW CS_KC  
AS  
SELECT XSB.学号,XSB.姓名,CJB.课程号,KCB.课程名,成绩  
  FROM XSB,CJB,KCB  
  WHERE XSB.学号=CJB.学号 AND CJB.课程号=KCB.课程号  
    AND 专业='计算机'  
  WITH CHECK OPTION;
```

### 5. 删除视图
```
DROP VIEW <视图名>
```

### 6. 更新视图  
```
- 可更新视图  
  (1) 没有使用连接函数、集合运算函数和组函数  
  (2) 创建视图的SELECT语句中没有聚合函数且没有GROUP BY、ONNECT BY、START WITH子句及DISTINCT关键字  
  (3) 创建视图的SELECT语句不包含从基表列通过计算所得的列  
  (4) 创建视图没有包含只读属性

- 插入数据  
  例:向CS_XS视图中插入一条记录:('151115','刘明义','计算机',男,'1996-3-2',50,'三好学生')  
  INSERT INTO CS_XS  
  VALUES('151115','刘明义','男',TO_DATE('19960302','YYYYMMDD'),'计算机',50,'三好学生');

- 修改数据  
  例:将XS_KC视图中学号为151101的学生的101号课程成绩改为90  
  UPDATE CS_KC SET 成绩=90 WHERE 学号='151101' AND 课程号='101';  
  视图CS_KC依赖于XSB和CJB两个基本表,对CS_KC视图的一次修改只能改变学号(源于XSB)或者课程号和成绩(源于CJB)

- 删除数据  
  使用DELETE语句可以通过视图删除基本表的数据,但要注意:对于依赖于多个基本表的视图,不能使用DELETE语句  
  语法和删除表一样DELETE FROM 视图名 WHERE 条件表达式  
```

## 五、索引
### 1. 索引的作用
```
- 快速存取数据  
- 既可以改善数据库性能,又可以保证列值的唯一性  
- 实现表与表之间的参照完整性  
- 在使用ORDER BY、GROUP BY子句进行数据检索时,利用索引可以减少排序和分组的时间  
```

### 2. 索引的分类
```
- 按存储方法分类  
  (1) B*树索引  
    B*树索引的存储结构类似图书的索引结构,有分支和叶两种类型的存储数据块,分支块相当于图书的大目录,叶块相当于索引到的具体的书叶  
    Oracle用B*树(B*-tree)机制存储索引条目,以保证用最短路径访问键值  
    默认情况下大多使用B*树索引,该索引就是通常所说的唯一索引、逆序索引等  
  (2) 位图索引  
    位图索引主要用来节省空间,减少Oracle对数据块的访问  
    它采用位图偏移方式来与表的行ID号对应  
    采用位图索引一般是在重复值太多的表字段情况下  

- 按功能和索引对象分类  
  (1) 唯一索引:不会有两行相同的索引键值  
  (2) 非唯一索引  
  (3) 分区索引:索引可以分散地存在于多个不同的表空间中,其优点是可以提高数据查询的效率  
  (4) 为排序索引:也称正向索引
  (5) 逆序索引:也称反向索引,该索引同样保持索引列按顺序排列,但是颠倒已索引的每列的字节  
  (6) 基于函数的索引:索引的一列或多列是一个函数或者表达式,索引根据函数或者表达式计算索引列的值  
```

### 3. 使用索引的原则
```
- 导入数据后再创建索引  
- 再适当的表和列上创建适当的索引  
- 合理设置复合索引中列的顺序  
- 限制表中索引的数量  
- 选择存储索引的表空间  
```

### 4. 创建索引
```
- 创建索引的条件  
  (1) 索引的表或簇必须在自己的模式中  
  (2) 必须在索引的表上具有INDEX权限  
  (3) 必须具有CREATE ANY INDEX权限  
- 语法格式  
  CREATE [UNIQUE|BITMAP] INDEX  /*索引类型*/  
    [<用户方案名>.]<索引名>  
  ON <表名>(<列名>|<列名表达式>[ASC|DESC][,...n])  
  [LOGGING|NOLOGGING]  /*指定是否创建相应的日志记录*/  
  [COMPUTE STATISTICS]  /*生成统计信息*/  
  [COMPASS|NOCOMPASS]  /*对复合索引进行压缩*/    
  [TABLESPACE <表空间名>]  /*索引所属表空间*/  
  [SORT|NOSORT]  /*指定是否对表进行排序*/  
  [REVERSE]  
```

### 5. 维护索引
```
使用ALTER INDEX命令维护索引必须在操作者自己的模式中,或者操作者拥有ALTER INDEX系统权限,语法格式如下:  
ALTER INDEX [<用户方案名>.]<索引名>   
[LOGGING|NOLOGGING]  /*指定是否创建相应的日志记录*/  
[TABLESPACE <表空间名>]  /*索引所属表空间*/  
[SORT|NOSORT]  /*指定是否对表进行排序*/  
[REVERSE]  
[RENAME TO <新索引名>]
```

### 6. 删除索引
```
DROP INDEX [<用户方案名>.]<索引名>  
```

## 六、数据完整性
### 1. 数据完整性的分类
```  
1. 域完整性  
  域完整性又称列完整性,指定一个数据集对某一个列是否有效和确定是否允许空值  
  域完整性通常是经过使用有效性检查来实现的,还可以通过限制数据类型、格式或者可能的取值范围来实现  

2. 实体完整性  
  实体完整性也称行完整性,要求表中的每一行有一个唯一的标识符,这个标识符就是主关键字  
  通过索引、UNIQUE约束、PRIMARY KEY约束可实现数据的实体完整性  

3. 参照完整性  
  主键是指在表中能唯一标识表的每个数据行的一个或多个表列  
  外检是指如果一个表的一个若干个字段的组合是另一个表的主键,则称该字段或字段组合为该表得到外键  
  一旦两个表定义了参照完整性,则有如下要求:  
  (1) 从表不能引用不存在的键值  
  (2) 如果主表中的键值更改了,那么在整个数据库中,对从表中该键值的所有引用都要进行一致的更改  
  (3) 如果主表中没有关联的记录,则不能讲记录添加到从表  
  (4) 如果要删除主表中的某一记录,应先删除从表中与该记录匹配的相关记录  

4. 完整性约束  
  完整性约束是通过限制列数据、行数据和表之间数据来保证数据完整性的有效方法  
  约束是保证数据完整性的标准方法  
  每一种数据完整性类型都可以由不同的约束类型来保障  
  约束确保有效的数据输入到列中并维护表与表之间的关系
  以下是完整性约束的分类:  
  (1) `NOT NULL`:指定表中某个列不允许空值,必须为该列提供值  
  (2) `UNIQUE`:使某个列或某些列的组合唯一,防止出现冗余值  
  (3) `PRIMARY KEY`:使某个列或某些列的组合唯一,也是表的主关键字  
  (4) `FOREIGN KEY`:使某个列或某些列为外关键字,其值与本表或者另表的主关键字匹配,实现引用完整性  
  (5) `CHECK`:指定表中的每一行数据必须满足的条件
```

### 2. 域完整性的实现
```
1. 在创建表时创建约束
CREATE TABLE <表名>(  
<列名> <数据类型> [DEFAULT <默认值>] [NOT NULL|NULL]  
[CONSTRAINT <CHECK约束名>] CHECK(<CHECK约束表达式>)  /*定义为列的约束*/  
[,...n]  
[CONSTRAINT <CHECK约束名>] CHECK(<CHECK约束表达式>)  /*定义为表的约束*/  
)  

2. 在修改表时创建约束
ALTER TABLE <表名>  
ADD( CONSTRINT <CHECK约束名> CHECK(<CHECK约束表达式>))  

3. 删除约束
ALTER TABLE <表名>  
DROP CONSTRAINT <CHECK约束名>  

4. PRIMARY KEY约束和UNIQUE约束的主要区别
- 一个表只能创建一个PRIMARY KEY约束,但可根据需要对不同的列创建若干个UNIQUE约束  

- PRIMARY KEY字段的值不允许为NULL,而UNIQUE字段的值可取NULL  

- 对于PRIMARY KEY约束与UNIQUE约束来说,都是由索引强制实现的  

- 在实现PRIMARY KEY约束与UNIQUE约束时,Oracle按照下面过程来实现  
  (1) 如果禁止该约束,则不创建索引  
  (2) 如果约束是允许的,且约束中的列时某个索引的一部分,则该索引用来强制约束  
  (3) 如果约束是允许的,且约束中的列都不是某个索引的一部分,那么按照下面的规则创建索引  
    ① 如果约束是可延迟的,则在这种约束的列上创建一个非唯一性索引  
    ② 如果约束是非可延迟的,则创建一个唯一性索引  
```

### 3. 实体完整性的实现
```
1. 创建表的同时创建约束
CREATE TABLE <表名>  /*指定表名*/  
(<列名> <数据类型> [NULL|NOT NULL]  /*定义字段*/  
  {[CONSTRAINT <约束名>]  /*定义约束名*/  
    PRIMARY KEY|UNIQUE}  /*定义约束类型*/  
    [,...n]  
  [,[CONSTRAINT <约束名>]{PRIMARY KEY|UNIQUE}(<列名>,[,...n])]  
  )  

2. 通过修改表来创建约束
ALTER TABLE <表名>  
ADD([CONSTRAINT <约束名>]{PRIMARY KEY|UNIQUE}(<列名>[,...n]))  

3. 删除约束
ALTER TABLE <表名>  
DROP CONSTRAINT <约束名>[,...n];  
```

### 4. 参照完整性的实现
```
1. 创建时要考虑的因素
(1) 在删除主表之前,必须删除FOREIGN KEY约束  
(2) 如果不删除或禁止FOREIGN KEY约束,则不能删除主表  
(3) 在删除包含主表的表空间之前,必须先删除FOREIGN KEY约束  

2. 创建表的同时定义外键约束
CREATE TABLE <从表名>  
(<列定义>[ CONSTRAINT <约束名>] REFERENCES <主表名>[(<列名>[,...n])]  
  [,...n]  
  [[CONSTRAINT <约束名>][FOREIGN KEY(<列名>[,...n])[<参照表达式>]]]  
);  

其中:  
<参照表达式>::=  
REFERENCES <主表名>[(<列名>[,...n])]  
[ ON DELETE {CASCADE|SET NULL}]  

3. 通过修改表定义外键约束
ALTER TABLE <表名>  
ADD CONSTRAINT <约束名>  
  FOREIGN KEY( <列名>[,...n])  
  REFERENCES <主表名>(<列名>[,...n])<参照表达式>  

4. 删除表间的参照关系
删除表间的参照关系,实际上删除从表的外键约束即可,语法格式与前面其他约束删除的格式相同  
```
